<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Class 12 ¬∑ LearningToControlClass</title><meta name="title" content="Class 12 ¬∑ LearningToControlClass"/><meta property="og:title" content="Class 12 ¬∑ LearningToControlClass"/><meta property="twitter:title" content="Class 12 ¬∑ LearningToControlClass"/><meta name="description" content="Documentation for LearningToControlClass."/><meta property="og:description" content="Documentation for LearningToControlClass."/><meta property="twitter:description" content="Documentation for LearningToControlClass."/><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../search_index.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script><link href="../../assets/wider.css" rel="stylesheet" type="text/css"/><link href="../../assets/redlinks.css" rel="stylesheet" type="text/css"/></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../../">LearningToControlClass</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><span class="tocitem">Class 1</span><ul><li><a class="tocitem" href="../../class01/class01/">Class 1 ‚Äî 08/22/2025</a></li><li><a class="tocitem" href="../../class01/background_materials/git_adventure_guide/">üöÄ Git Adventure Guide</a></li></ul></li><li><a class="tocitem" href="../../class02/overview/">Class 2</a></li><li><a class="tocitem" href="../../class03/class03/">Class 3</a></li><li><a class="tocitem" href="../../class04/class04/">Class 4</a></li><li><a class="tocitem" href="../../class05/class05/">Class 5</a></li><li><a class="tocitem" href="../../class06/class06/">Class 6</a></li><li><a class="tocitem" href="../../class07/class07/">Class 7</a></li><li><a class="tocitem" href="../../class08/class08/">Class 8</a></li><li><a class="tocitem" href="../../class09/class09/">Class 9</a></li><li><a class="tocitem" href="../../class10/class10/">Class 10</a></li><li><a class="tocitem" href="../../class11/class11/">Class 11</a></li><li class="is-active"><a class="tocitem" href>Class 12</a><ul class="internal"><li class="toplevel"><a class="tocitem" href="#Foundations-of-Neural-Operators"><span>Foundations of Neural Operators</span></a></li><li><a class="tocitem" href="#Notations-and-definitions"><span>Notations and definitions</span></a></li><li class="toplevel"><a class="tocitem" href="#Operator-basics"><span>Operator basics</span></a></li><li><a class="tocitem" href="#Approximations"><span>Approximations</span></a></li><li><a class="tocitem" href="#PCA"><span>PCA</span></a></li><li><a class="tocitem" href="#DeepONet"><span>DeepONet</span></a></li><li><a class="tocitem" href="#Overcoming-the-curse-of-dimensionality"><span>Overcoming the curse of dimensionality</span></a></li><li class="toplevel"><a class="tocitem" href="#Fourier-Neural-Operator"><span>Fourier Neural Operator</span></a></li><li><a class="tocitem" href="#Walkthrough"><span>Walkthrough</span></a></li><li><a class="tocitem" href="#Zero-shot-Superresolution"><span>Zero-shot Superresolution</span></a></li><li class="toplevel"><a class="tocitem" href="#Galerkin-transformer"><span>Galerkin transformer</span></a></li><li class="toplevel"><a class="tocitem" href="#Potential-improvements-and-connection-to-the-PINNs"><span>Potential improvements and connection to the PINNs</span></a></li><li class="toplevel"><a class="tocitem" href="#Large-scale-surrogates"><span>Large-scale surrogates</span></a></li><li class="toplevel"><a class="tocitem" href="#References"><span>References</span></a></li></ul></li><li><a class="tocitem" href="../../class13/class13/">Class 13</a></li><li><a class="tocitem" href="../../class15/class15/">Class 15</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Class 12</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Class 12</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/LearningToOptimize/LearningToControlClass" title="View the repository on GitHub"><span class="docs-icon fa-brands">ÔÇõ</span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/LearningToOptimize/LearningToControlClass/blob/main/class12/class12.md" title="Edit source on GitHub"><span class="docs-icon fa-solid">ÔÅÑ</span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Class-12-‚Äî-11/07/2025"><a class="docs-heading-anchor" href="#Class-12-‚Äî-11/07/2025">Class 12 ‚Äî 11/07/2025</a><a id="Class-12-‚Äî-11/07/2025-1"></a><a class="docs-heading-anchor-permalink" href="#Class-12-‚Äî-11/07/2025" title="Permalink"></a></h1><p><strong>Presenter:</strong> Pedro Paulo</p><p><strong>Topic:</strong> Neural operators (FNO, Galerkin Transformer); large-scale surrogates</p><h1 id="Foundations-of-Neural-Operators"><a class="docs-heading-anchor" href="#Foundations-of-Neural-Operators">Foundations of Neural Operators</a><a id="Foundations-of-Neural-Operators-1"></a><a class="docs-heading-anchor-permalink" href="#Foundations-of-Neural-Operators" title="Permalink"></a></h1><h2 id="Notations-and-definitions"><a class="docs-heading-anchor" href="#Notations-and-definitions">Notations and definitions</a><a id="Notations-and-definitions-1"></a><a class="docs-heading-anchor-permalink" href="#Notations-and-definitions" title="Permalink"></a></h2><p>Let&#39;s start by setting up some notations:</p><ul><li>‚ÄéDerivatives <span>$\dfrac{\partial}{\partial t}$</span> are going to be written as <span>$\partial_t$</span>, and, in the case of derivatives <strong>w.r.t. time</strong>, they could be written as <span>$\partial_t x=\dot x$</span>.</li><li>‚ÄéIntegrals <span>$\int \{\cdot\} \ \mathrm dt$</span> are going to be written as <span>$\int \mathrm dt \ \{\cdot\}$</span>.</li></ul><p>And having some definitions:</p><ul><li>‚Äé<strong>Vectors</strong> are <em>lists of numbers</em>, i.e., a vector <span>$v$</span> lives in <span>$\mathbb R^{d_v}$</span>, and can be thought as a list of <span>$d_v$</span> numbers, all in <span>$\mathbb R$</span>. More generally, vectors could live in a generic <em>vector space</em> <span>$V$</span>, so we would have <span>$v\in V$</span>. </li><li>‚Äé<strong>Functions</strong> are vector-to-vector mapping, i.e., a function <span>$f$</span> brings a <span>$v \in \mathbb R^{d_v}$</span> to a <span>$w \in \mathbb R^{d_w}$</span>, and we define that as <span>$f: \mathbb R^{d_v} \rightarrow \mathbb R^{d_w}$</span>.  More generally, functions could operate on a generic <em>vector space</em> <span>$V$</span> and <span>$W$</span>, so we would have <span>$f: V \rightarrow W$</span>. </li><li>‚Äé<strong>Operators</strong> are function-to-functions mapping, i.e., an operator <span>$A$</span> brings an <span>$f:\mathbb R^{d_{v1}} \rightarrow \mathbb R^{d_{w1}}$</span> to a <span>$g: \mathbb R^{d_{v2}} \rightarrow \mathbb R^{d_{w2}}$</span>. More generally, operators could operate on generic <em>function spaces</em>, so we would have an operator <span>$A$</span> bringing an <span>$f:V_1 \rightarrow W_1$</span> to a <span>$g:V_2 \rightarrow W_2$</span>. </li></ul><p>Key differences:</p><ul><li>‚ÄéA vector is <em>naturally</em> discrete. Therefore, the input-output pair for functions are also <em>naturally</em> discrete. </li><li>‚ÄéA function is <em>naturally</em> continuous. Therefore, the input-output pair for operators are also <em>naturally</em> continuous.</li></ul><p>It is said that Neural Networks (NN) are <strong>universal function approximators</strong> [1,2], in this section we&#39;re going to create the idea of <strong>universal operator approximators</strong>, that map functions to functions, using something called <strong>Neural Operators</strong>.</p><p>A NN <span>$\mathcal N$</span> can be thought as a general <strong>function</strong> <span>$\mathcal N: X \times \Theta \rightarrow Y$</span>, where <span>$X$</span> and <span>$Y$</span> are vector spaces, and <span>$\Theta$</span> is the parameter space. So we take elements <span>$x \in X$</span> and we <em>learn</em> how to map those onto <span>$y\in Y$</span>, by means of changing the parameters <span>$\theta \in \Theta$</span>. That way, we can approximate any function (that&#39;s where the &quot;universal function approximator&quot; comes from) that maps <span>$X \rightarrow Y$</span>.  In a similar way we can think about a Neural Operator <span>$\mathcal G^\dagger: \mathcal X \times \Theta \rightarrow \mathcal Y$</span>, where <span>$\mathcal X$</span> and <span>$\mathcal Y$</span> are function spaces, and <span>$\Theta$</span> is the parameter space. Now, instead of learning how to map <em>vectors</em>, we&#39;re going to learn the mapping of <em>functions</em>. This general idea will be expanded further.</p><p><strong>Why are functions important?</strong> Everything in the real world is a function! If we want to predict the airflow around a car, the stress caused by deforming a metal bar, the temperature of a reactor, the weather (and the list goes on), we would need to use functions. When putting into a computer we are going to need to mesh our function, otherwise we&#39;d not be able to process it. But we&#39;re going to think about functions when designing the architecture of these Neural Operators.</p><p><strong>Why approximate operators?</strong> Let&#39;s start with a parallel with image processing. Imagine that I have a Convolutional NN (CNN) that take as an input a (discrete) <span>$256\times256$</span> image (let&#39;s imagine it in grayscale for simplicity). The input to this CNN would then be a <span>$v \in \mathbb R^{256 \times 256}$</span>, where each element <span>$v_i \in \mathbb R \ ; v_i \in [0,1]$</span>. Although this is a typical architecture for image processing [3], and it has been around since 1989 [4], it has a couple of limitations:</p><ul><li>‚ÄéThe input <strong>has to</strong> be <span>$256\times256$</span>, the need of different dimension leads to a new NN and a new training.</li><li>‚ÄéIn case of regression, the output <strong>has to</strong> a fixed dimension, the need of different dimension leads to a new NN and a new training.</li></ul><p>For the case of image processing, where there&#39;s no trivial underlying function behind the image, we cannot take advantage of the use of Neural Operators, but in the case of distributions of physical quantities, e.g., temperature, where there&#39;s a underlying function behind it, we can leverage the use of Neural Operators to understand distribution function, and make predictions/controls based on it, decoupling the parametrization <span>$\Theta$</span> from the discretization of the data. [5] <em>et al.</em> compared the errors of two networks: U-Net (NN topology) and PCA-Net (Neural operator topology), that were trained on different discretizations of the <em>same underlying function</em>, and the result is shown below:</p><p><img src="../Figures/unetvspca.png" alt="Alt text"/></p><p>This brings a concept (that we&#39;ll try to keep with our definition of Neural Operators) called <strong>Discretization Invariance</strong>:</p><ul><li>‚ÄéWhen we have Discretization Invariance we de-couple the parameters and the cost from the discretization, i.e., when changing the discretization the error doesn&#39;t vary.</li><li>‚ÄéIf our model is Discretization Invariable, we can use information at different discretizations to train, and we can transfer parameters learned for one discretization to another, that leads to something called &quot;zero-shot super-resolution&quot;, that basically consists of training into a smaller discretization and predicting into a bigger one, due to the Discretization Invariance. This concept, together with its limitations, will be discussed in the &quot;Fourier Neural Operator&quot; section.</li></ul><h1 id="Operator-basics"><a class="docs-heading-anchor" href="#Operator-basics">Operator basics</a><a id="Operator-basics-1"></a><a class="docs-heading-anchor-permalink" href="#Operator-basics" title="Permalink"></a></h1><p>Let the operator <span>$\mathcal G: \mathcal X \rightarrow \mathcal Y$</span>, where <span>$\mathcal X$</span> and  are separable Banach spaces (mathematical way of saying that <span>$\mathcal X$</span> and <span>$\mathcal Y$</span> are spaces of functions) of vector-valued functions:</p><p class="math-container">\[\begin{align}
\mathcal X=\{x: D\rightarrow \mathbb R\}, \ \ \ D \subseteq\mathbb R^d
\\
\mathcal Y=\{y: D\rightarrow \mathbb R\}
\end{align}\]</p><p>For example, <span>$D$</span> is a cut plane of a biological tissue (<span>$D \subseteq\mathbb R^2$</span>) under the application of electric fields, and <span>$x\in\mathcal X$</span> and <span>$y\in\mathcal Y$</span> are temperatures before and after the application of said fields. The operator <span>$\mathcal G$</span> is given by:</p><p class="math-container">\[\rho c_p\partial_tT =\nabla \cdot(k\nabla T) + \sigma|E|^2-Q\]</p><p>where</p><p class="math-container">\[\begin{align}
\rho \text{ is the tissue&#39;s density}
\\
c_p \text{ is the tissue&#39;s heat capacity}
\\
T \text{ is the temperature distribution on the tissue}
\\
k \text{ is the tissue&#39;s thermal conductivity}
\\
\sigma \text{ is the tissue&#39;s electrical conductivity}
\\
E \text{ is the electric field distribution}
\\
Q \text{ is the heat transfer, from blood/metabolism}
\end{align}\]</p><p>This is one specific case of an operator, but any PDE can be thought as an operator.</p><h2 id="Approximations"><a class="docs-heading-anchor" href="#Approximations">Approximations</a><a id="Approximations-1"></a><a class="docs-heading-anchor-permalink" href="#Approximations" title="Permalink"></a></h2><p>Imagine that I want to approximate this operator <span>$\mathcal G$</span> by means of an <span>$\mathcal G^\dagger: \mathcal X\times\Theta \rightarrow \mathcal Y$</span>, a first idea could be to find two linear mappings, here called <span>$K_\mathcal W$</span> and <span>$L_\mathcal W$</span> such that <span>$K_\mathcal WL_\mathcal W \approx I$</span>, where <span>$I$</span> is the identity operator (i.e., by applying <span>$K_\mathcal W$</span> and <span>$L_\mathcal W$</span> to <em>all</em> <span>$w \in \mathcal W$</span> we will return to the same <span>$w$</span>), and that by applying <span>$K_\mathcal W$</span> to a <span>$w\in\mathcal W$</span> we can project this <span>$w$</span> onto a non-infinite space <span>$\mathbb R^{d_\mathcal W}$</span> (one example of such operator is the FFT family, we&#39;re we approximate every function to a finite set of coefficients that represent the original functions&#39; sines and cosines). By doing this to both <span>$\mathcal X$</span> and <span>$\mathcal Y$</span>, we&#39;re going to have two non-infinite representations of <span>$\mathcal X$</span> and <span>$\mathcal Y$</span>, on <span>$\mathbb R^{n}$</span> and <span>$\mathbb R^{m}$</span>, respectively, and we can map this two representations using a non-linear function <span>$\varphi$</span>. </p><p>A general diagram is shown below:</p><p><img src="../Figures/diagram.png" alt="Alt text"/></p><p>In this case, we can see that our <span>$\mathcal G^\dagger$</span> can be given by <span>$\mathcal G^\dagger = K_\mathcal X \circ \varphi\circ L_\mathcal Y$</span>, where <span>$K_\mathcal X$</span> and <span>$L_\mathcal Y$</span> are the operators that project <span>$\mathcal X$</span> and <span>$\mathcal Y$</span> to the non-infinite dimension spaces <span>$\mathbb R^{n}$</span> and <span>$\mathbb R^{n}$</span>, respectively, and <span>$\varphi$</span> is a non-linear function that maps <span>$\mathbb R^{n}$</span> to <span>$\mathbb R^{m}$</span>. Different selections of the set {<span>$K_\mathcal W$</span>, <span>$L_\mathcal W$</span>, <span>$\varphi$</span>} generate different classes of Neural Operators.</p><p>We can, from this, see the first limitation of this technique: we&#39;re limited by how well is the approximation of <span>$K_\mathcal WL_\mathcal W \approx I$</span>. It turns out that, as described by [5], this is approximation is fairly general: Universal approximation: Let:</p><ul><li>‚Äé <span>$\mathcal X$</span> and <span>$\mathcal Y$</span> be separable Banach spaces.</li><li>‚Äé <span>$\mathcal G: \mathcal X \rightarrow \mathcal Y$</span> be continuous.</li></ul><p>For any <span>$U\subset \mathcal X$</span> compact and <span>$\epsilon &gt; 0$</span>, <em>there exists</em> continuous, linear maps <span>$K_\mathcal X:\mathcal X \rightarrow \mathbb R^n$</span>,  <span>$L_\mathcal Y:\mathcal Y \rightarrow \mathbb R^m$</span>, and <span>$\varphi: \mathbb R^n \rightarrow \mathbb R^m$</span> such that:</p><p class="math-container">\[\sup_{u\in U} \| \mathcal G(u)-\mathcal G^\dagger(u)\|_\mathcal Y &lt; \epsilon\]</p><p>Average approximation: Let: </p><ul><li>‚Äé <span>$\mathcal X$</span> be separable Banach spaces, and <span>$\mu \in \mathcal P(\mathcal X)$</span> be a probability measure in <span>$\mathcal X$</span>.</li><li>‚Äé <span>$\mathcal G \in L_\mu^p(\mathcal X;\mathcal Y)$</span> for some <span>$1\leq p &lt; \infty$</span></li></ul><p>If <span>$\mathcal Y$</span> is separable Hilbert space, and <span>$\epsilon &gt; 0$</span>, <em>there exists</em> continuous, linear maps <span>$K_\mathcal X:\mathcal X \rightarrow \mathbb R^n$</span>,  <span>$L_\mathcal Y:\mathcal Y \rightarrow \mathbb R^m$</span>, and <span>$\varphi: \mathbb R^n \rightarrow \mathbb R^m$</span> such that:</p><p class="math-container">\[\| \mathcal G(u)-\mathcal G^\dagger(u)\|_{L_\mu^p(\mathcal X;\mathcal Y)} &lt; \epsilon\]</p><p>Let&#39;s start by giving two classes of Neural Operators, the Principal Component Analysis Network (PCA-NET) and the Deep Operator Network (DeepONet).</p><h2 id="PCA"><a class="docs-heading-anchor" href="#PCA">PCA</a><a id="PCA-1"></a><a class="docs-heading-anchor-permalink" href="#PCA" title="Permalink"></a></h2><p>First proposed by [6], we&#39;re going to define the PCA-NET approximation by analyzing our input and output spaces using a PCA-like technique. Let:</p><ul><li>‚Äé<span>$\mathcal X$</span> and <span>$\mathcal Y$</span> be separable Banach spaces, and let <span>$x\in K\subset\mathcal X$</span>, with <span>$K$</span> compact.</li><li>‚Äé<span>$\mathcal G$</span> (the operator that we&#39;re trying to approximate) be continuous.</li><li>‚Äé<span>$\varphi_j:\mathbb R^n \times \Theta \rightarrow \mathbb R^m$</span> be multiple neural networks.</li><li>‚Äé<span>$\xi_1,\text{...},\xi_n$</span> be the PCA basis functions of the input space <span>$\mathcal X$</span>. The operator <span>$K_\mathcal X$</span> for a given <span>$x\in \mathcal X$</span> would then be <span>$K_\mathcal X(x) :=\mathrm Lx = \{\langle\xi_j,x\rangle\}_j$</span>.</li><li>‚Äé<span>$\psi_1,\text{...},\psi_m$</span> be the PCA basis functions of the output space <span>$\mathcal Y$</span>.</li></ul><p>The final approximation <span>$\mathcal G^\dagger_{\text{PCA}}:\mathcal X \times \Theta \rightarrow \mathcal Y$</span> is then given by:</p><p class="math-container">\[\begin{align}
\mathcal{G}^\dagger_{\text{PCA}}&amp;(x;\theta)(u)=\sum_{j=0}^m\varphi_j(\mathrm Lx;\theta)\psi_j(u) \ \ \ \ \forall\ x\in\mathcal X  \ \ \ \ u\in D_u
\end{align}\]</p><p>That is, the output is the <em>linear combination</em> of the PCA output basis functions {<span>$\psi_j$</span>}, weighted by NN coefficients <span>$\varphi_j$</span>, that have as input the <span>$\mathrm Lx$</span> mapping of the input to the PCA space.</p><h2 id="DeepONet"><a class="docs-heading-anchor" href="#DeepONet">DeepONet</a><a id="DeepONet-1"></a><a class="docs-heading-anchor-permalink" href="#DeepONet" title="Permalink"></a></h2><p>Proposed by [7], the DeepONet generalizes the idea of PCA-NET, by means of <em>learning</em> the PCA basis functions of the output space <span>$\mathcal Y$</span>, i.e., <span>$\psi_1,...,\psi_m$</span> are now NNs. The parameter space is then composed of two distinct set of parameters to be learned: <span>$\theta_\varphi$</span>, the same parameters as the original PCA-NET, and <span>$\theta_\psi$</span>, the parameters for the PCA basis functions of the output space. We will then have:</p><p class="math-container">\[\begin{align}
\mathcal G^\dagger_{\text{DeepONet}}&amp;(x;\theta)(u)=\sum_{j=0}^m\varphi_j(\mathrm Lx;\theta_\varphi)\psi_j(u;\theta_\psi) \ \ \ \ \forall\ x\in\mathcal X  \ \ \ \ u\in D_u
\end{align}\]</p><h2 id="Overcoming-the-curse-of-dimensionality"><a class="docs-heading-anchor" href="#Overcoming-the-curse-of-dimensionality">Overcoming the curse of dimensionality</a><a id="Overcoming-the-curse-of-dimensionality-1"></a><a class="docs-heading-anchor-permalink" href="#Overcoming-the-curse-of-dimensionality" title="Permalink"></a></h2><p>One of the big problems of these approaches is the fact <span>$L_\mathcal Y$</span> is a linear combination of the {<span>$\psi_j$</span>}. This leads to the need of an doubly exponential growth in the amount of data, when compared to <span>$n$</span> (the size of the PCA basis functions of the input space <span>$\mathcal X$</span>), to achieve convergence [8]. To overcome this difficulty, we&#39;re going to generalize this idea of linear approximation of operators to the non-linear case.</p><p>Let:</p><ul><li>‚Äé<span>$\mathcal X$</span> and <span>$\mathcal Y$</span> be function spaces over <span>$\Omega \subset \mathbb R^d$</span></li><li>‚Äé<span>$\mathcal G^\dagger$</span> is the composition of non-linear operators: <span>$\mathcal G^\dagger=S_1\circ \text{...} \circ S_L$</span>. In the linear case, as described before, <span>$S_1 = K_\mathcal X$</span>, <span>$S_L = K_\mathcal Y$</span> and they&#39;re connected through multiple <span>$\varphi_j$</span>.</li></ul><p>The above definition <em>looks a lot</em> like the typical definition of NNs, where each one of the <span>$S_l$</span> is a layer of your NN. And, as we&#39;re going to see, it is! At least it is a generalization of the definition of NN to function space. [9] proposed to create each one of this <span>$S_l$</span> as follows:</p><p class="math-container">\[S_l(a)(x) = \sigma_l\bigg( W_la(x) + b_l + \int_\Omega\mathrm dz \ \kappa_l(x,z)a(z)  \bigg), \ \ \ \ x \in \Omega\]</p><p>where:</p><ul><li>‚Äé<span>$\sigma_l:\mathbb R^k\rightarrow\mathbb R^k$</span> is the non-linear activation function.</li><li>‚Äé<span>$W_l\in\mathbb R^k$</span> is a term related to a &quot;residual network&quot;. This term is not necessary for convergence, but it&#39;s credited to help with convergence speed.</li><li>‚Äé<span>$b_l\in\mathbb R^k$</span> is the bias term.</li><li>‚Äé<span>$\kappa_l:\Omega\times\Omega\rightarrow\mathbb R^k$</span> is the kernel function.</li></ul><p>The main distinction between this approach and the traditional NN approach is the <span>$\kappa_l$</span> term, instead of the traditional weights, and the fact that the input <span>$a(x)$</span> is a <em>function</em>, instead of a vector like the traditional NNs. Different selections of <span>$\kappa_l$</span> generate different classes of these non-linear Neural Operators, but we&#39;re going to focus on the transform <span>$\kappa_l$</span>, more specifically the Fourier Neural Operator and the Garlekin Transformer.</p><h1 id="Fourier-Neural-Operator"><a class="docs-heading-anchor" href="#Fourier-Neural-Operator">Fourier Neural Operator</a><a id="Fourier-Neural-Operator-1"></a><a class="docs-heading-anchor-permalink" href="#Fourier-Neural-Operator" title="Permalink"></a></h1><p>Let <span>$\kappa_l(x,z)=\kappa_l(x-z)$</span>, the integral will then become:</p><p class="math-container">\[\int_\Omega \mathrm dz \ \kappa_l(x,z)a(z) = \int_\Omega \mathrm dz \ \kappa_l(x-z)a(z) =\kappa_l(x) * a(x)\]</p><p>where <span>$*$</span> represents the convolution operator.</p><p>And, as we know from Fourier Transform Theory, </p><p class="math-container">\[\mathcal F\{\kappa_l(x)*a(x)\} = \mathcal F\{\kappa_l(x)\} \cdot\mathcal F\{a(x)\} :=\hat \kappa_l(v)\hat a(v)\]</p><p>where <span>$\mathcal F\{\cdot\}$</span> represents the Fourier transform of a function.</p><p>We can than reduce the single layer <span>$S_l$</span>, shown before, to the following:</p><p class="math-container">\[S_l(a)(x) = \sigma_l\bigg( W_la(x) + b_l + \mathcal F^{-1}\{\hat\kappa_l(v) \hat a(v)\}  \bigg), \ \ \ \ x \in \Omega \ \ \ \ v \in \Omega^\ddagger\]</p><p>where <span>$\Omega^\ddagger \subset \mathbb C^d$</span> represent the spectral Fourier space related to <span>$\Omega$</span>.</p><p>This is basically what defines the Fourier Neural Operator (FNO): the Neural Operator <span>$\mathcal G^\dagger=S_1\circ \text{...} \circ S_L$</span> where each one of these <span>$S_l$</span> is done by &quot;filtering&quot; the previous output function using its Fourier expansions, first described by [9].</p><p>The overall diagram of the process is shown bellow, and a walkthrough will follow:</p><p><img src="../Figures/FourierDiagram.png" alt="Alt text"/></p><h2 id="Walkthrough"><a class="docs-heading-anchor" href="#Walkthrough">Walkthrough</a><a id="Walkthrough-1"></a><a class="docs-heading-anchor-permalink" href="#Walkthrough" title="Permalink"></a></h2><h3 id="Lifting-(P)-and-Projection-(Q)-layers"><a class="docs-heading-anchor" href="#Lifting-(P)-and-Projection-(Q)-layers">Lifting (P) and Projection (Q) layers</a><a id="Lifting-(P)-and-Projection-(Q)-layers-1"></a><a class="docs-heading-anchor-permalink" href="#Lifting-(P)-and-Projection-(Q)-layers" title="Permalink"></a></h3><p>The Lifting layer (P) maps the input function from its original low-dimensional channel space into a higher-dimensional latent space. This is typically done with a pointwise linear layer (a 1√ó1 convolution). The reason for this expansion is that the Fourier layers approximate nonlinear operators more effectively when they operate on a wide latent representation, giving the model the expressive capacity needed to learn complex mappings such as PDE solution operators.</p><p>The Projection layer (Q) performs the opposite transformation: it takes the final high-dimensional latent features produced by the Fourier layers and compresses them back into the desired output channel dimension. Like the lifting layer, it is usually a pointwise linear map. This step converts the latent representation into the actual predicted function (e.g., pressure, velocity, temperature), acting as the final interface between the learned operator and the physical output space.</p><h3 id="Fourier-layers"><a class="docs-heading-anchor" href="#Fourier-layers">Fourier layers</a><a id="Fourier-layers-1"></a><a class="docs-heading-anchor-permalink" href="#Fourier-layers" title="Permalink"></a></h3><p>As stated before, the Fourier Layers are composed following the equation below:</p><p class="math-container">\[S_l(a)(x) = \sigma_l\bigg( W_la(x) + b_l + \mathcal F^{-1}\{\hat\kappa_l(v) \hat a(v)\}  \bigg), \ \ \ \ x \in \Omega \ \ \ \ v \in \Omega^\dagger\]</p><p>An interesting thing about the the kernel <span>$\hat \kappa_l(v)$</span> is that it has a non-zero value for the first couple of values (here called <span>$K_\kappa$</span>) and zero for the last values. That is, the product <span>$\hat\kappa_l(v) \cdot\hat a(v)$</span> is given by:</p><p class="math-container">\[(\hat\kappa_l(v) \hat a(v))_j = \begin{cases} W_\kappa\hat a_j(v), &amp; j\leq K_\kappa\\0, &amp; j&gt; K_\kappa \end{cases}\]</p><p>where <span>$W_\kappa$</span> are the (trainable) weights for the kernel, and <span>$j$</span> represents each mode (&quot;frequency component&quot;).</p><p>We can see this &quot;low-pass filter&quot; behavior of the kernel represented on the &quot;zoom&quot; of the general diagram (b), where the high frequencies vanish, while the remaining low frequencies are multiplied by a certain weight. After this &quot;filtering&quot; and weighting, we apply the inverse FFT get the <span>$\mathcal F^{-1}\{\hat\kappa_l(v) \cdot\hat a(v)\}$</span> term.</p><p>Meanwhile we also have the so called &quot;residual network&quot;, represented by <span>$W_la(x)$</span>, with trainable <span>$W_l$</span>. It is not strictly necessary to be used, but it helps with convergence speed, and the (also trainable) bias term <span>$b_l$</span>, suppressed on the figure. The sum of all the aforementioned terms is then passed by a non-linear activation function <span>$\sigma$</span>, defined <em>a priori</em>.</p><p>And, finally, T (defined <em>a priori</em>) of these layers are concatenated, before being projected down by the layer <strong>Q</strong>, to produce the output <span>$u(x)$</span>.</p><h2 id="Zero-shot-Superresolution"><a class="docs-heading-anchor" href="#Zero-shot-Superresolution">Zero-shot Superresolution</a><a id="Zero-shot-Superresolution-1"></a><a class="docs-heading-anchor-permalink" href="#Zero-shot-Superresolution" title="Permalink"></a></h2><p>An interesting fact about the usage of Neural Operators is their <strong>Discretization invariance</strong>, that is, as shown on Figure 1, a change in discretization didn&#39;t lead to a change in test error.</p><p>This was leveraged using FNO to the so-called Zero-shot Superresolution: where the Neural Operator can be trained on a dataset with a smaller discretization (i.e., on a coarser grid) and, using the same Network predict using a finer grid. The following figure showcase this for the Burgers 1D equation, shown below, and with <span>$x \in \mathbb R^{256}$</span>.</p><p class="math-container">\[\text{Burgers 1D equation: } \frac{\partial u}{‚àÇ t} + \frac{1}{2}\frac{\partial u^2}{\partial x} = \nu \frac{\partial^2 u}{\partial x^2}\]</p><p><img src="../Figures/PlotLowRes.png" alt="alt text"/> With the maximum difference between Prediction and Ground Truth being <code>~ 6e-3</code>. </p><p>After the training, the same Network was used to predict outputs for <span>$x\in\mathbb R^{2048}$</span>, and we have the following: <img src="../Figures/PlotHighRes.png" alt="alt text"/></p><p>With the maximum difference between Prediction and Ground Truth being, once again, <code>~ 6e-3</code>. </p><h1 id="Galerkin-transformer"><a class="docs-heading-anchor" href="#Galerkin-transformer">Galerkin transformer</a><a id="Galerkin-transformer-1"></a><a class="docs-heading-anchor-permalink" href="#Galerkin-transformer" title="Permalink"></a></h1><p>An interesting thing about transformer is that, in general, the whole output function depends globally on the input function. I.e., let the function <span>$f(x)$</span>, solution of a certain PDE that has as input <span>$g(x)$</span>, and let <span>$x_0\in\Omega$</span> a fixed point; <span>$f(x_0)$</span> will depend on <span>$g(x)\forall x\in\Omega$</span>. With this in mind, and creating a parallel with transformers and Attention, Shuhao <em>et al.</em> [10] developed the Galerkin transformer, that uses an &quot;attention-based&quot; kernel <span>$\kappa_l(x,z)$</span>.</p><p>This kernel embodies the essential non-local coupling across the spatial domain, dictating how information at point <span>$z$</span> influences the output at point <span>$x$</span>. In its continuous form, the kernel <span>$\kappa_l$</span> is too complex to parameterize directly. We can achieve an approximation by representing the kernel through a factorized form: <span>$\kappa_l(x, z) \approx \phi(Q_l a(x))^\top \psi(K_l a(z))$</span>, where <span>$Q_l$</span> and <span>$K_l$</span> are learnable linear maps, and <span>$\phi$</span> and <span>$\psi$</span> are feature transformations. Intuitively, each spatial location is mapped to a vector that describes its role in global interactions. </p><p>The matrices <span>$Q_l$</span> and <span>$K_l$</span> act as projection operators, transforming the local feature <span>$a(x)$</span> into a query vector <span>$q_x = Q_l a(x)$</span> and <span>$a(z)$</span> into a key vector <span>$k_z = K_l a(z)$</span>, respectively. These vectors share a common latent space, and their inner product, <span>$q_x \cdot k_z$</span>, measures the affinity or relevance between the two locations. </p><p>To complete the information aggregation, a third linear map, <span>$V_l$</span>, transforms <span>$a(z)$</span> into a value vector <span>$v_z = V_l a(z)$</span>. The resulting approximation to the kernel integral <span>$\int_\Omega \mathrm dz\ \kappa_l(x, z)a(z)$</span> is then written as the sum: <span>$\sum_{z} \phi(Q_l a(x))^\top \psi(K_l a(z))\, v_z$</span>. The full discrete neural operator layer thus becomes <span>$S_l(a)(x) = \sigma_l\left(W_l a(x) + b_l + \sum_{z} \phi(Q_l a(x))^\top \psi(K_l a(z))\, V_l a(z)\right)$</span>, where <span>$W_l$</span> and <span>$b_l$</span> handle local transformations, and <span>$\sigma_l$</span> introduces nonlinearity. All projection matrices and feature maps are learned, enabling the network to infer the kernel&#39;s structure and the relevant latent dynamics.</p><p>The Galerkin transformer is a specific case where the function <span>$a(x)$</span> is expanded in a finite basis <span>$\{\phi_i(x)\}_{i=1}^M$</span> using a coefficient vector <span>$c=(c_1,\dots,c_M)$</span>. In this case, attention is computed between these modal coefficients rather than spatial points. Each mode <span>$i$</span> produces its own query, key, and value vectors via the same projection operators, resulting in the modal update: <span>$\tilde{c}_i = \sigma_l\left(W_l c_i + b_l + \sum_{j} \phi(Q_l c_i)^\top \psi(K_l c_j)\, V_l c_j \right)$</span>. This modal attention mechanism ensures the learned operator acts within the finite-dimensional Galerkin subspace, preserving the projection structure of PDE solvers while allowing for adaptive, data-driven coupling between modes.</p><h1 id="Potential-improvements-and-connection-to-the-PINNs"><a class="docs-heading-anchor" href="#Potential-improvements-and-connection-to-the-PINNs">Potential improvements and connection to the PINNs</a><a id="Potential-improvements-and-connection-to-the-PINNs-1"></a><a class="docs-heading-anchor-permalink" href="#Potential-improvements-and-connection-to-the-PINNs" title="Permalink"></a></h1><p>All the networks shown are classified as &quot;PDE-agnostic&quot;, that is, there&#39;s no implicit step that ensures that our predicted output matches the PDE that we&#39;re trying to solve. But PINN-based structures are being develop to connect this two concepts [11].</p><h1 id="Large-scale-surrogates"><a class="docs-heading-anchor" href="#Large-scale-surrogates">Large-scale surrogates</a><a id="Large-scale-surrogates-1"></a><a class="docs-heading-anchor-permalink" href="#Large-scale-surrogates" title="Permalink"></a></h1><p>Traditional FNO applications face a significant limitation when tackling massive, real-world 3D simulations where the input data and network weights cannot fit onto a single GPU. [12] introduced a model-parallel version of FNOs that utilizes domain-decomposition to distribute both the input data and the network weights across multiple GPUs. This innovation allowed the model to handle problems involving billions of variables (e.g., up to 2.6 billion variables on 512 A100 GPUs), making it practical for large-scale applications like simulating multiphase CO‚ÇÇ dynamics for carbon capture and storage (CCS). By shifting the computational strugle to the training phase, the resulting surrogate model achieved multiple orders of magnitude speedup during inference compared to traditional numerical solvers.</p><p>Another challenge in training deep surrogate models is the storage-intensive process of creating large, high-fidelity datasets. The conventional approach (generating simulations, saving them to disk, and reading them back, commonly named offline training)creates an I/O and storage bottleneck that limits dataset size and diversity. [13] introduced an open-source online training framework designed to suppress this issue. The framework organizes the simultaneous and executes the numerical solvers and a training server in parallel, allowing data to be streamed directly to the network without intermediate disk storage. This file-avoiding method enables training with a potentially limitless amount of unique data, only constrained by available compute resources. By exposing models like FNOs and Fully Connected Networks to significantly larger and more diverse datasets, the framework demonstrated improved model generalization, reducing validation errors and achieving accuracy gains of 16% for FNO and 68% for Fully Connected Networks compared to traditional offline training.</p><hr/><h1 id="References"><a class="docs-heading-anchor" href="#References">References</a><a id="References-1"></a><a class="docs-heading-anchor-permalink" href="#References" title="Permalink"></a></h1><p>[1] McCulloch, Warren S., and Walter Pitts. &quot;A logical calculus of the ideas immanent in nervous activity.&quot; The bulletin of mathematical biophysics 5.4 (1943): 115-133.</p><p>[2] Chen, Tianping, and Hong Chen. &quot;Universal approximation to nonlinear operators by neural networks with arbitrary activation functions and its application to dynamical systems.&quot; IEEE transactions on neural networks 6.4 (1995): 911-917.</p><p>[3] Anwar, Syed Muhammad, et al. &quot;Medical image analysis using convolutional neural networks: a review.&quot; Journal of medical systems 42.11 (2018): 226.</p><p>[4] LeCun, Yann, et al. &quot;Backpropagation applied to handwritten zip code recognition.&quot; Neural computation 1.4 (1989): 541-551.</p><p>[5] Neural operator: Learning maps between function spaces with applications to pdes.</p><p>[6] Bhattacharya, Kaushik, et al. &quot;Model reduction and neural networks for parametric PDEs.&quot; The SMAI journal of computational mathematics 7 (2021): 121-157.</p><p>[7] Lu, Lu, Pengzhan Jin, and George Em Karniadakis. &quot;Deeponet: Learning nonlinear operators for identifying differential equations based on the universal approximation theorem of operators.&quot; arXiv preprint arXiv:1910.03193 (2019).</p><p>[8] Cohen, Albert, and Ronald DeVore. &quot;Approximation of high-dimensional parametric PDEs.&quot; Acta Numerica 24 (2015): 1-159.</p><p>[9] Li, Zongyi, et al. &quot;Fourier neural operator for parametric partial differential equations.&quot; arXiv preprint arXiv:2010.08895 (2020).</p><p>[10] Cao, Shuhao. &quot;Choose a transformer: Fourier or galerkin.&quot; Advances in neural information processing systems 34 (2021): 24924-24940.</p><p>[11] Dhingra, Mrigank, et al. &quot;Localized PCA-Net Neural Operators for Scalable Solution Reconstruction of Elliptic PDEs.&quot; arXiv preprint arXiv:2509.18110 (2025).</p><p>[12] Grady, Thomas J., et al. &quot;Model-parallel Fourier neural operators as learned surrogates for large-scale parametric PDEs.&quot; Computers &amp; Geosciences 178 (2023): 105402.</p><p>[13] Meyer, Lucas Thibaut, et al. &quot;Training deep surrogate models with large scale online learning.&quot; International Conference on Machine Learning. PMLR, 2023.</p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../../class11/class11/">¬´ Class 11</a><a class="docs-footer-nextpage" href="../../class13/class13/">Class 13 ¬ª</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.14.1 on <span class="colophon-date" title="Wednesday 19 November 2025 14:04">Wednesday 19 November 2025</span>. Using Julia version 1.11.7.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
